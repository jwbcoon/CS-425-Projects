# Assignment 2: Lychrel Data

In this assignment, I spent about one day working on converting the original lychrel.cpp file into a threaded program to improve its execution time. I developed this program primarily in my PDE (Personal Development Environment) using g++ on my Ubuntu laptop, and I tested this program both on my PDE and on blue. For fun, I first tried running the unthreaded variant of the program to test its runtime via ssh on blue which, hilariously, ran for more than an hour before the server forcibly disconnected me from the ssh session. There was a second program which iterated on the original by providing some threading, and, running this program, it returned accurate results 

## Improvement Iterations

Here's a table showing the improvements I did to make the application go faster.  The **Time** column in the table represents the _wall-clock time_ for a program run. The speedups are all relative to an estimated 1 hour runtime.

| Commit | File | Time | Speedup | Changes |
| :-----: | ----- | :------: | :-----: | ------- |
| [Initial Commit](https://github.com/jwbcoon/CS-425-Projects/commit/bebb407ac7019fd0f2abbf7df17d30549f805478) | [unthreaded](lychrel.cpp.orig) | 1 hour+ | &mdash; | Initial unthreaded version - no changes. |
| [Initial Commit](https://github.com/jwbcoon/CS-425-Projects/commit/bebb407ac7019fd0f2abbf7df17d30549f805478) | [threaded](lychrel.cpp.othread) | [1m38.885s](https://github.com/jwbcoon/CS-425-Projects/assets/89538296/6ef747a5-9d47-411f-9266-dd58125a9f04) | 36.36x | Initial threaded version - no changes written by me. 36x speedup is remarkable! |
| [Commit 2](https://github.com/jwbcoon/CS-425-Projects/commit/b6c82c2c36c6cbac31ce01ef20e06b32dd5a1492) | [simple threaded](lychrel.cpp.joe1) | [1m53.69s](https://github.com/jwbcoon/CS-425-Projects/assets/89538296/0cd628fa-6005-458c-8984-17c16f864a6f) | 31.67x | Added threading similar to that in the file written in the initial commit's threaded version, but with reduced amount of code within the mutex lock_guard. Unfortunately, mine was slower than the threaded code provided in the initial commit! |
| [Commit 3](https://github.com/jwbcoon/CS-425-Projects/commit/c74ed20e35822b81debd10418146e69f476779d2) | [chunk processing + 20 threads](lychrel.cpp.joe2) | [1m20.959s](https://github.com/jwbcoon/CS-425-Projects/assets/89538296/3acc1434-6e66-4d36-b8cb-e1de926ac059) | 44.47x | Applied the getNext method from the LychrelData.h class header to provide a vector instance to work on for each thread, therefore data synchronization concentrates at the front of the process when providing data to operate on from the input file, then threads can more easily work asynchronously when performing write and arithmetic operations on the data elements for the rest of the processing. Additionally, I added 10 more threads (for a total 20) to see how this might impact performance. Seemed promising! |
| [Commit 4](https://github.com/jwbcoon/CS-425-Projects/commit/2d531ecbd92748cb25b2928aa30f430e583fc83f) and [Commit 5](https://github.com/jwbcoon/CS-425-Projects/commit/34953d61170452764576be05239fbedbae467457) | [chunk processing + MaxThreads = 5% of data.size()](lychrel.cpp) + [changed header](LychrelData.h) | [0m47.325s](https://github.com/jwbcoon/CS-425-Projects/assets/89538296/48220bfb-6be4-4636-b60d-a0b130e9d4a9) | 76.07x | Looking over the flow of the program in Commit 3, I noticed that there was redundancy in the bounds checking of the data array when performing the ThreadChunkSize partitioning. I sought to remove redundant operations by changing the LychrelData.h file where the nextData() method was implemented for reading multiple numbers from the file at once. In addition, I decided to push the number of threads the program would spawn for the task. In my PDE, I was experimenting with using 1000 threads, but ran into issues when bringing this to blue. I also noticed a great increase in time spent on system calls, which made me think that excess threads were stepping on each others toes when it came to synchronous activities. I decided that relating the number of threads as a portion of the data set would be a good idea and, after some quick trial runs, determined 5% to be a satisfactory proportion. This summarizes commit 4, but, upon running my code with a calculated MaxThread value on blue, I found myself meeting compilation errors. I decided to simply hard code the 5% value of the Final dataset .bins (250 threads), and was pleased to see a 76x speedup from the original program. |

## Improvement Iterations 2: Electric Bugaloo
After my initial submission, Dave and I discussed my implementation of the project and I resolved to write a variant which satisfies the minimum requirements. Since Dave's runtime was about 12 minutes on the baseline, unoptimized threaded application variant, I will use that to relate speedup measurements.

| Commit | File | Time | Speedup | Changes |
| :-----: | ----- | :------: | :-----: | ------- |
| [Speedy Commit](https://github.com/jwbcoon/CS-425-Projects/commit/2c16af9b325ff6371353318fa27515b67668fb4c) | [final lychrel.cpp](lychrel.cpp) | [1m8.237s](https://github.com/jwbcoon/CS-425-Projects/assets/89538296/9ad546f6-8a30-4eba-a615-686a05ca78ab) | 10.55x | I created a method, consume, which partitions the dataset into load balanced dispatches to each thread, dynamically scheduling the load in response the net progress of the threads through the lychrel processing task. This commit involves the implementation of an array, checkpoints, which holds milestone values with which the consume method adjusts work dispatches to threads. I also instantiated two separate mutexes for constructing the work dispatches and recording values for maxIter. |
| [Alt Speedy Commit](https://github.com/jwbcoon/CS-425-Projects/commit/dce1126f2b3ff3075f2ad9e3781d07958c0a93d7) | [alternate lychrel.cpp](lychrel.cpp.alt) | [1m9.400s](https://github.com/jwbcoon/CS-425-Projects/assets/89538296/93989270-5367-4170-932d-4ae4419a628e) | 10.37x | A continuation of the code implemented in the Speedy Commit, this iteration focused on changing the implementation of the getNext(count, numbers) method within LychrelData.h. The motive of these changes was to enhance speed by maintaining continuity of operations on one reference to the "numbers" parameter for each thread, reducing the expense of copying the data. I attempted this by making the getNext() method return a pointer to the numbers parameter which is modified by the method. However, this implementation ultimately showed to be marginally slower than the Speedy Commit implementation. |

